<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>像素艺术生成器 - 泰拉瑞亚风格</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
            color: #e0e0e0;
            overflow-x: hidden;
            background-image: url('https://zh.minecraft.wiki/images/Background.png');
            background-attachment: fixed;
            background-size: cover;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
    }
        
        .container {
            max-width: 100%;
            background-color: rgba(26, 26, 46, 0.8);
            padding: 15px;
            display: flex;
            gap: 20px;
            position: relative;
        }

        .main-content {
            flex: 1;
            margin-right: 280px;
            background-color: rgba(40, 40, 80, 0.7);
            border: 4px solid #5a3921;
            border-image: 
                linear-gradient(
                    to bottom right,
                    #5a3921 0%,
                    #8b5a2b 25%,
                    #5a3921 50%,
                    #8b5a2b 75%,
                    #5a3921 100%
                ) 1;
            box-shadow: 
                0 0 10px rgba(0, 0, 0, 0.5),
                inset 0 0 20px rgba(0, 0, 0, 0.3);
            padding: 15px;
        }
        
        h1 {
            text-align: center;
            color: #ff9933;
            text-shadow: 
                2px 2px 0 #8b5a2b,
                4px 4px 0 #5a3921;
            margin-bottom: 20px;
            font-size: 28px;
            letter-spacing: 2px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: min-content;
            min-width: 200px;
            padding: 15px;
            background-color: #2d1a12;
            border: 4px solid #5a3921;
            border-image: 
                linear-gradient(
                    to bottom right,
                    #5a3921 0%,
                    #8b5a2b 25%,
                    #5a3921 50%,
                    #8b5a2b 75%,
                    #5a3921 100%
                ) 1;
            box-shadow: 
                0 0 10px rgba(0, 0, 0, 0.5),
                inset 0 0 20px rgba(0, 0, 0, 0.3);
            position: fixed;
            right: 20px;
            top: 20px;
            height: calc(100vh - 40px);
            overflow-y: auto;
            box-sizing: border-box;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 170px;
            background-color: rgba(90, 58, 33, 0.5);
            padding: 10px;
            border: 2px solid #8b5a2b;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

                /* 文件上传样式 */
        .file-upload-wrapper {
            margin-top: 10px;
        }

        .custom-file-upload {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
            margin-top: 5px;
        }

        .custom-file-upload input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .custom-file-upload span {
            display: block;
            padding: 8px;
            border: 2px solid #5a3921;
            border-radius: 0;
            background-color: #2d1a12;
            color: #ffcc99;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            text-align: center;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
            transition: all 0.2s;
            cursor: pointer;
        }

        .custom-file-upload span:hover {
            background-color: #8b5a2b;
            transform: translateY(-2px);
            box-shadow: 0 4px 0 #5a3921;
        }

        .custom-file-upload span:active {
            transform: translateY(0);
            box-shadow: 0 2px 0 #5a3921;
        }

        .custom-file-upload span::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: all 0.5s;
        }

        .custom-file-upload span:hover::before {
            left: 100%;
        }
        
        label {
            margin-bottom: 8px;
            color: #ffcc99;
            font-size: 12px;
            text-shadow: 1px 1px 0 #5a3921;
        }
        
        select, input, button {
            padding: 8px;
            border: 2px solid #5a3921;
            border-radius: 0;
            background-color: #2d1a12;
            color: #ffcc99;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
            transition: all 0.2s;
        }
        
        select:focus, input:focus, button:focus {
            outline: none;
            border-color: #ff9933;
        }
        
        button {
            background-color: #5a3921;
            color: #ffcc99;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: 1px 1px 0 #2d1a12;
            position: relative;
            overflow: hidden;
        }
        
        button:hover {
            background-color: #8b5a2b;
            transform: translateY(-2px);
            box-shadow: 0 4px 0 #5a3921;
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 0 #5a3921;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: all 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        .color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #color {
            width: 60px;
            height: 30px;
            padding: 0;
            border: 2px solid #5a3921;
            cursor: pointer;
        }
        
        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            overflow: auto;
            background-color: #1a1a2e;
            border: 4px solid #5a3921;
            padding: 10px;
            box-shadow: 
                inset 0 0 20px rgba(0, 0, 0, 0.5),
                0 0 10px rgba(0, 0, 0, 0.7);
        }
        
        #pixelCanvas {
            border: 2px solid #5a3921;
            background-color: white;
            position: relative;
            z-index: 5; /* 确保画布在最上层 */
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            image-rendering: pixelated;
        }
        
        .template-preview {
            display: none;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            background-color: rgba(90, 58, 33, 0.3);
            padding: 10px;
            border: 2px solid #5a3921;
        }
        
        .template {
            width: 50px;
            height: 50px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #2d1a12;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }
        
        .template:hover {
            border-color: #ff9933;
            transform: scale(1.05);
        }
        
        .tools {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .tool-btn {
            flex: 1;
            min-width: 100px;
            background-color: #5a3921;
            color: #ffcc99;
            border: 2px solid #8b5a2b;
            padding: 10px;
            font-size: 10px;
        }
        
        .tool-btn:hover {
            background-color: #8b5a2b;
        }
        
        .template-import {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        }

        .template-import label {
            margin-bottom: 0;
            font-size: 10px;
            color: #ffcc99;
        }
        .eraser-active {
            background-color: #e74c3c !important;
            color: white !important;
        }
        
        .palette {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .palette-color {
            width: 20px;
            height: 20px;
            border: 2px solid #5a3921;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.3);
        }
        
        .palette-color:hover {
            transform: scale(1.2);
            box-shadow: 0 0 5px white;
        }
        
        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #2d1a12;
            border-left: 1px solid #5a3921;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #5a3921;
            border: 1px solid #8b5a2b;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #8b5a2b;
        }
        
        /* 响应式设计 */
        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
            }
            
            .main-content {
                margin-right: 0;
                margin-bottom: 20px;
            }
            
            .controls {
                position: static;
                width: auto;
                height: auto;
                margin-top: 20px;
            }
        }
        
        /* 像素化标题装饰 */
        .title-decoration {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .pixel {
            width: 10px;
            height: 10px;
            margin: 2px;
        }
        
        .pixel-orange {
            background-color: #ff9933;
        }
        
        .pixel-brown {
            background-color: #5a3921;
        }
        
        .pixel-gold {
            background-color: #ffcc66;
        }

        /* 动画控制样式 */
        .animation-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .animation-buttons button {
            flex: 1;
            padding: 8px;
            font-size: 10px;
        }

        .animation-settings {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .animation-settings input[type="range"] {
            flex: 1;
        }

        .animation-settings span {
            font-size: 10px;
            color: #ffcc99;
        }

        .frames-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-height: 200px;
            overflow-y: auto;
            padding: 5px;
            background-color: rgba(90, 58, 33, 0.3);
            border: 2px solid #5a3921;
        }

        .frame-preview {
            position: relative;
            width: 50px;
            height: 50px;
            border: 2px solid #5a3921;
            background-color: #2d1a12;
        }

        .frame-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .frame-preview span {
            position: absolute;
            bottom: -15px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 8px;
            color: #ffcc99;
        }
        /*进度条样式*/
        .progress-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            padding: 10px;
            background-color: rgba(90, 58, 33, 0.3);
            border: 2px solid #5a3921;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .progress-bar {
            flex: 1;
            height: 20px;
            -webkit-appearance: none;
            background-color: #2d1a12;
            border: 2px solid #5a3921;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 20px;
            background: #ff9933;
            border: 2px solid #5a3921;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .progress-bar::-moz-range-thumb {
            width: 15px;
            height: 20px;
            background: #ff9933;
            border: 2px solid #5a3921;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .progress-text {
            font-size: 12px;
            color: #ffcc99;
            text-shadow: 1px 1px 0 #5a3921;
            min-width: 80px;
            text-align: center;
        }

        @media (max-width: 1200px) {
            .progress-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .progress-text {
                text-align: center;
                margin-top: 5px;
            }
        }
    </style>
    
    <!-- 进度条样式 -->
    <style>
        .progress-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            padding: 10px;
            background-color: rgba(90, 58, 33, 0.3);
            border: 2px solid #5a3921;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .progress-bar {
            flex: 1;
            height: 20px;
            background-color: #2d1a12;
            border: 2px solid #5a3921;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(
                to right,
                #5a3921 0%,
                #8b5a2b 50%,
                #ff9933 100%
            );
        }

        .progress-text {
            font-size: 12px;
            color: #ffcc99;
            text-shadow: 1px 1px 0 #5a3921;
            min-width: 40px;
            text-align: center;
        }

        @media (max-width: 1200px) {
            .progress-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .progress-text {
                text-align: center;
                margin-top: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="title-decoration">
                <div class="pixel pixel-brown"></div>
                <div class="pixel pixel-orange"></div>
                <div class="pixel pixel-gold"></div>
                <div class="pixel pixel-orange"></div>
                <div class="pixel pixel-brown"></div>
            </div>
            
            <h1>像素艺术生成器</h1>
            
            <div class="title-decoration">
                <div class="pixel pixel-brown"></div>
                <div class="pixel pixel-orange"></div>
                <div class="pixel pixel-gold"></div>
                <div class="pixel pixel-orange"></div>
                <div class="pixel pixel-brown"></div>
            </div>
            
            <div class="canvas-container" style="display: flex; flex-direction: column; align-items: center;">
                <canvas id="pixelCanvas"></canvas>
                <!-- 可交互进度条 - 放在画布下方 -->
                <div class="progress-container" style="width: 90%; margin-top: 10px; margin-left: auto; margin-right: auto;">
                    <input type="range" id="frameProgress" min="1" max="1" value="1" class="progress-bar" style="width: 100%;">
                    <span class="progress-text">第<span id="currentFrame">1</span>帧，共<span id="totalFrames">1</span>帧</span>
                </div>
            </div>

            <div class="tools">
                <button id="undoBtn" class="tool-btn" title="撤销 (Ctrl+Z)">撤销</button>
                <button id="redoBtn" class="tool-btn" title="重做 (Ctrl+Y)">重做</button>
                <button id="clearCanvas" class="tool-btn">清空画布</button>
                <button id="saveProject" class="tool-btn">保存项目</button>
                <button id="loadProject" class="tool-btn">加载项目</button>
                <button id="exportPNG" class="tool-btn">导出PNG</button>
            </div>
            
            <div class="template-preview" id="templatePreviews">
                <!-- 模板预览将在这里动态生成 -->
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>绘图工具</label>
                <select id="drawingTool">
                    <option value="pencil" selected>铅笔</option>
                    <option value="eraser">橡皮擦</option>
                    <option value="line">直线</option>
                    <option value="rectangle">矩形</option>
                    <option value="circle">圆形</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>调色板</label>
                <div class="palette" id="colorPalette">
                    <!-- 调色板颜色将在这里动态生成 -->
                </div>
                <button id="saveColorBtn" style="margin-top: 5px;">保存当前颜色</button>
            </div>
            
            <div class="control-group">
                <label for="gridSize">画布大小</label>
                <select id="gridSize">
                    <option value="16">16×16 (小图标)</option>
                    <option value="32" selected>32×32 (头像)</option>
                    <option value="64">64×64</option>
                    <option value="128">128×128</option>
                    <option value="256">256×256</option>
                    <option value="512">512×512</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="pixelSize">像素大小</label>
                <select id="pixelSize">
                    <option value="5">5px</option>
                    <option value="10">10px</option>
                    <option value="15" selected>15px</option>
                    <option value="20">20px</option>
                    <option value="25">25px</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>颜色</label>
                <div class="color-picker">
                    <input type="color" id="color" value="#3498db">
                    <button id="randomColor">随机</button>
                    <button id="gradientMode">渐变模式</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>模板</label>
                <select id="templateSelect">
                    <option value="">选择模板...</option>
                    <option value="heart">爱心</option>
                    <option value="smile">笑脸</option>
                    <option value="tree">圣诞树</option>
                    <option value="cat">猫咪</option>
                </select>
                <div class="file-upload-wrapper">
                    <label for="imageUpload">或导入图片</label>
                    <div class="custom-file-upload">
                        <input type="file" id="imageUpload" accept="image/*">
                        <span>选择文件</span>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h3>动画控制</h3>
                <div class="animation-buttons">
                    <button id="addFrame">添加</button>
                    <button id="deleteFrame">删除</button>
                    <button id="copyFrame">复制</button>
                    <button id="playAnimation">播放</button>
                </div>
                <div class="animation-settings">
                    <label>帧率: <input type="range" id="frameRate" min="1" max="30" value="12"></label>
                    <span id="frameRateValue">12 FPS</span>
                </div>
                <div class="frames-preview" id="framesPreview"></div>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 获取DOM元素
            const canvas = document.getElementById('pixelCanvas');
            const ctx = canvas.getContext('2d');
            const gridSizeSelect = document.getElementById('gridSize');
            const pixelSizeSelect = document.getElementById('pixelSize');
            const colorPicker = document.getElementById('color');
            const randomColorBtn = document.getElementById('randomColor');
            const templateSelect = document.getElementById('templateSelect');
            const imageUpload = document.getElementById('imageUpload');
            const clearCanvasBtn = document.getElementById('clearCanvas');
            const exportPNGBtn = document.getElementById('exportPNG');
            const templatePreviews = document.getElementById('templatePreviews');
            const drawingToolSelect = document.getElementById('drawingTool');
            
            // 初始化变量
            let gridSize = parseInt(gridSizeSelect.value);
            let pixelSize = parseInt(pixelSizeSelect.value);
            let currentColor = colorPicker.value;
            let isDrawing = false;
            let isGradientMode = false;
            let currentTool = 'pencil';
            let startX, startY;
            let paletteColors = JSON.parse(localStorage.getItem('paletteColors')) || [];
            
            // 撤销/重做历史记录
            const MAX_HISTORY = 50;
            let historyStack = [];
            let redoStack = [];
            
            // 预定义模板
            const templates = {
                heart: {
                    size: 16,
                    data: [
                        [0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0],
                        [0,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                        [0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0],
                        [0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ],
                    color: '#ff0000'
                },
                smile: {
                    size: 16,
                    data: [
                        [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0],
                        [1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0],
                        [1,1,0,1,1,0,0,0,0,1,1,0,1,1,0,0],
                        [1,1,0,1,1,0,0,0,0,1,1,0,1,1,0,0],
                        [1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0],
                        [1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0],
                        [1,1,0,1,0,0,0,0,0,0,1,0,1,1,0,0],
                        [1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0],
                        [0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0]
                    ],
                    color: '#ffff00'
                },
                tree: {
                    size: 16,
                    data: [
                        [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0],
                        [0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0],
                        [0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0],
                        [0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0]
                    ],
                    color: '#00aa00'
                },
                cat: {
                    size: 16,
                    data: [
                        [0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0],
                        [0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                        [0,1,1,1,0,0,1,1,1,1,0,0,1,1,1,0],
                        [0,1,1,1,0,0,1,1,1,1,0,0,1,1,1,0],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                        [1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,1],
                        [1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1],
                        [0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0]
                    ],
                    color: '#ffa500'
                }
            };
            
            // 初始化画布
            function initCanvas() {
                gridSize = parseInt(gridSizeSelect.value);
                pixelSize = parseInt(pixelSizeSelect.value);
                
                // 限制画布大小以避免性能问题
                const maxCanvasSize = 1024 * 4; // 4MB
                const requiredSize = gridSize * pixelSize;
                
                if (requiredSize > maxCanvasSize) {
                    // 自动调整像素大小以适应最大尺寸
                    pixelSize = Math.floor(maxCanvasSize / gridSize);
                    pixelSizeSelect.value = pixelSize;
                    alert(`画布太大，已自动调整像素大小为${pixelSize}px以保持性能`);
                }
                
                canvas.width = gridSize * pixelSize;
                canvas.height = gridSize * pixelSize;
                
                // 绘制网格
                drawGrid();
                
                // 生成模板预览
                generateTemplatePreviews();
            }
            
            // 绘制网格
            function drawGrid() {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 0.5;
                
                for (let x = 0; x <= gridSize; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * pixelSize, 0);
                    ctx.lineTo(x * pixelSize, gridSize * pixelSize);
                    ctx.stroke();
                }
                
                for (let y = 0; y <= gridSize; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * pixelSize);
                    ctx.lineTo(gridSize * pixelSize, y * pixelSize);
                    ctx.stroke();
                }
            }
            
            // 生成模板预览
            function generateTemplatePreviews() {
                templatePreviews.innerHTML = '';
                
                for (const [name, template] of Object.entries(templates)) {
                    const previewCanvas = document.createElement('canvas');
                    previewCanvas.width = template.size;
                    previewCanvas.height = template.size;
                    previewCanvas.className = 'template';
                    previewCanvas.dataset.template = name;
                    
                    const previewCtx = previewCanvas.getContext('2d');
                    
                    // 绘制模板预览
                    for (let y = 0; y < template.data.length; y++) {
                        for (let x = 0; x < template.data[y].length; x++) {
                            if (template.data[y][x]) {
                                previewCtx.fillStyle = template.color;
                                previewCtx.fillRect(x, y, 1, 1);
                            }
                        }
                    }
                    
                    previewCanvas.addEventListener('click', function() {
                        applyTemplate(name);
                    });
                    
                    templatePreviews.appendChild(previewCanvas);
                }
            }
            
            // 应用模板
            function applyTemplate(templateName) {
                const template = templates[templateName];
                currentColor = template.color;
                colorPicker.value = currentColor;
                
                // 计算缩放比例
                const scale = gridSize / template.size;
                
                // 清空画布
                drawGrid();
                
                // 保存状态
                saveState();
                updateUndoRedoButtons();
                
                // 绘制模板
                for (let y = 0; y < template.data.length; y++) {
                    for (let x = 0; x < template.data[y].length; x++) {
                        if (template.data[y][x]) {
                            const scaledX = Math.floor(x * scale);
                            const scaledY = Math.floor(y * scale);
                            const scaledSize = Math.max(1, Math.floor(scale));
                            
                            ctx.fillStyle = currentColor;
                            ctx.fillRect(
                                scaledX * pixelSize, 
                                scaledY * pixelSize, 
                                scaledSize * pixelSize, 
                                scaledSize * pixelSize
                            );
                        }
                    }
                }
            }
            
            // 从图片导入
            function importImage(file) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // 清空画布
                        drawGrid();
                        
                        // 计算缩放比例
                        const scale = Math.min(
                            canvas.width / img.width,
                            canvas.height / img.height
                        );
                        
                        // 绘制图像
                        ctx.drawImage(
                            img, 
                            0, 0, img.width, img.height,
                            0, 0, img.width * scale, img.height * scale
                        );
                        
                        // 像素化处理
                        pixelateImage();
                    };
                    img.src = e.target.result;
                };
                
                reader.readAsDataURL(file);
            }
            
            // 像素化图像
            function pixelateImage() {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const pixelX = x * pixelSize;
                        const pixelY = y * pixelSize;
                        
                        // 获取中心点颜色
                        const centerX = pixelX + Math.floor(pixelSize / 2);
                        const centerY = pixelY + Math.floor(pixelSize / 2);
                        
                        const index = (centerY * canvas.width + centerX) * 4;
                        const r = data[index];
                        const g = data[index + 1];
                        const b = data[index + 2];
                        const a = data[index + 3];
                        
                        // 填充整个像素块
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
                        ctx.fillRect(pixelX, pixelY, pixelSize, pixelSize);
                    }
                }
            }
            
            // 获取鼠标位置对应的网格坐标
            function getGridPosition(event) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((event.clientX - rect.left) / pixelSize/scaleFactor);
                const y = Math.floor((event.clientY - rect.top) / pixelSize/scaleFactor);
                
                return { 
                    x: Math.max(0, Math.min(x, gridSize - 1)),
                    y: Math.max(0, Math.min(y, gridSize - 1))
                };
            }
            
            // 保存当前画布状态
            function saveState() {
                // 保存当前状态到历史记录
                const state = canvas.toDataURL('image/png');
                historyStack.push(state);
                
                // 限制历史记录数量
                if (historyStack.length > MAX_HISTORY) {
                    historyStack.shift();
                }
                
                // 清空重做栈
                redoStack = [];
            }
            
            // 恢复画布状态
            function restoreState(state) {
                const img = new Image();
                img.onload = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = state;
            }
            
            // 撤销操作
            function undo() {
                if (historyStack.length > 0) {
                    const state = historyStack.pop();
                    redoStack.push(canvas.toDataURL('image/png'));
                    restoreState(state);
                    updateUndoRedoButtons();
                }
            }
            
            // 重做操作
            function redo() {
                if (redoStack.length > 0) {
                    const state = redoStack.pop();
                    historyStack.push(canvas.toDataURL('image/png'));
                    restoreState(state);
                    updateUndoRedoButtons();
                }
            }
            
            // 绘制直线
            function drawLine(x1, y1, x2, y2) {
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = (x1 < x2) ? 1 : -1;
                const sy = (y1 < y2) ? 1 : -1;
                let err = dx - dy;
                
                while(true) {
                    drawPixel(x1, y1);
                    
                    if (x1 === x2 && y1 === y2) break;
                    const e2 = 2 * err;
                    if (e2 > -dy) { err -= dy; x1 += sx; }
                    if (e2 < dx) { err += dx; y1 += sy; }
                }
            }
            
            // 绘制矩形
            function drawRectangle(x1, y1, x2, y2, filled = true) {
                const minX = Math.min(x1, x2);
                const maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2);
                const maxY = Math.max(y1, y2);
                
                if (filled) {
                    for (let y = minY; y <= maxY; y++) {
                        for (let x = minX; x <= maxX; x++) {
                            drawPixel(x, y);
                        }
                    }
                } else {
                    // 绘制边框
                    for (let x = minX; x <= maxX; x++) {
                        drawPixel(x, minY);
                        drawPixel(x, maxY);
                    }
                    for (let y = minY + 1; y < maxY; y++) {
                        drawPixel(minX, y);
                        drawPixel(maxX, y);
                    }
                }
            }
            
            // 绘制圆形
            function drawCircle(x1, y1, x2, y2, filled = true) {
                const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const centerX = x1;
                const centerY = y1;
                
                for (let y = -radius; y <= radius; y++) {
                    for (let x = -radius; x <= radius; x++) {
                        if (x*x + y*y <= radius*radius + radius*0.8) { // 添加0.8因子使圆形更平滑
                            if (filled || Math.abs(x*x + y*y - radius*radius) <= radius) {
                                const px = Math.round(centerX + x);
                                const py = Math.round(centerY + y);
                                if (px >= 0 && px < gridSize && py >= 0 && py < gridSize) {
                                    drawPixel(px, py);
                                }
                            }
                        }
                    }
                }
            }
            
            // 绘制像素
            function drawPixel(x, y) {
                if (currentTool === 'eraser') {
                    ctx.fillStyle = '#ffffff'; // 橡皮擦使用白色
                } else {
                    ctx.fillStyle = currentColor;
                }
                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                
                // 重新绘制网格线
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
            }
            
            // 填充算法 (类似油漆桶工具)
            function floodFill(startX, startY, targetColor, replacementColor) {
                // 将颜色转换为字符串比较
                targetColor = colorToRGBA(targetColor);
                replacementColor = colorToRGBA(replacementColor);
                
                // 如果目标颜色和替换颜色相同，不做任何操作
                if (targetColor === replacementColor) return;
                
                // 获取初始像素颜色
                const initialPixel = ctx.getImageData(startX * pixelSize, startY * pixelSize, 1, 1).data;
                const initialColor = `rgba(${initialPixel[0]}, ${initialPixel[1]}, ${initialPixel[2]}, ${initialPixel[3] / 255})`;
                
                // 如果初始颜色不是目标颜色，不做任何操作
                if (initialColor !== targetColor) return;
                
                // 使用队列实现泛洪填充
                const queue = [{x: startX, y: startY}];
                const width = gridSize;
                const height = gridSize;
                
                // 记录已访问的像素
                const visited = new Array(width * height).fill(false);
                
                while (queue.length > 0) {
                    const {x, y} = queue.shift();
                    const index = y * width + x;
                    
                    // 检查边界和是否已访问
                    if (x < 0 || x >= width || y < 0 || y >= height || visited[index]) {
                        continue;
                    }
                    
                    // 获取当前像素颜色
                    const pixel = ctx.getImageData(x * pixelSize, y * pixelSize, 1, 1).data;
                    const currentColor = `rgba(${pixel[0]}, ${pixel[1]}, ${pixel[2]}, ${pixel[3] / 255})`;
                    
                    // 如果颜色匹配，则填充并检查相邻像素
                    if (currentColor === targetColor) {
                        ctx.fillStyle = replacementColor;
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        
                        // 重新绘制网格线
                        ctx.strokeStyle = '#e0e0e0';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        
                        visited[index] = true;
                        
                        // 添加相邻像素到队列
                        queue.push({x: x + 1, y});
                        queue.push({x: x - 1, y});
                        queue.push({x, y: y + 1});
                        queue.push({x, y: y - 1});
                    }
                }
            }
            
            // 将颜色转换为RGBA字符串
            function colorToRGBA(color) {
                // 如果是十六进制颜色
                if (color.startsWith('#')) {
                    const r = parseInt(color.substr(1, 2), 16);
                    const g = parseInt(color.substr(3, 2), 16);
                    const b = parseInt(color.substr(5, 2), 16);
                    return `rgba(${r}, ${g}, ${b}, 1)`;
                }
                
                // 如果是rgb或rgba颜色
                return color;
            }
            
            // 生成随机相近颜色（基于当前颜色）
            function getRandomColor(baseColor = currentColor) {
                // 将十六进制颜色转换为HSL
                const hexToHsl = hex => {
                    let r = parseInt(hex.slice(1, 3), 16) / 255;
                    let g = parseInt(hex.slice(3, 5), 16) / 255;
                    let b = parseInt(hex.slice(5, 7), 16) / 255;
                    
                    let max = Math.max(r, g, b), min = Math.min(r, g, b);
                    let h, s, l = (max + min) / 2;
                    
                    if (max === min) {
                        h = s = 0; // achromatic
                    } else {
                        let d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        
                        switch(max) {
                            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                            case g: h = (b - r) / d + 2; break;
                            case b: h = (r - g) / d + 4; break;
                        }
                        h /= 6;
                    }
                    
                    return { h: h * 360, s: s * 100, l: l * 100 };
                };
                
                // 将HSL转换为十六进制
                const hslToHex = (h, s, l) => {
                    h /= 360;
                    s /= 100;
                    l /= 100;
                    
                    let r, g, b;
                    
                    if (s === 0) {
                        r = g = b = l; // achromatic
                    } else {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1/6) return p + (q - p) * 6 * t;
                            if (t < 1/2) return q;
                            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        };
                        
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        
                        r = hue2rgb(p, q, h + 1/3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1/3);
                    }
                    
                    const toHex = x => {
                        const hex = Math.round(x * 255).toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    };
                    
                    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                };
                
                // 获取基础颜色的HSL值
                let {h, s, l} = hexToHsl(baseColor);
                
                // 限制饱和度和亮度在美观范围内
                s = Math.max(60, Math.min(90, s));
                l = Math.max(40, Math.min(80, l));
                
                // 在HSL空间中进行更平滑的调整
                // 色相变化±10度，保持变化方向一致（顺时针）
                const newH = (h + Math.random() * 10 + 360) % 360;
                // 饱和度轻微变化±5%
                const newS = Math.max(60, Math.min(90, s + Math.random() * 10 - 5));
                // 亮度轻微变化±5% 
                const newL = Math.max(40, Math.min(80, l + Math.random() * 10 - 5));
                
                return hslToHex(newH, newS, newL);
            }
            
            // 导出为PNG
            function exportToPNG() {
                const link = document.createElement('a');
                link.download = 'pixel-art.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
            
            // 保存项目
            function saveProject() {
                const project = {
                    gridSize: gridSize,
                    pixelSize: pixelSize,
                    currentColor: currentColor,
                    canvasData: canvas.toDataURL('image/png'),
                    paletteColors: paletteColors,
                    version: 1
                };
                
                const data = JSON.stringify(project);
                const blob = new Blob([data], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.download = 'pixel-art-project.json';
                link.href = url;
                link.click();
                
                URL.revokeObjectURL(url);
            }
            
            // 加载项目
            function loadProject() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = e => {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        try {
                            const project = JSON.parse(e.target.result);
                            
                            // 验证项目文件
                            if (!project.version || project.version !== 1) {
                                throw new Error('不兼容的项目文件版本');
                            }
                            
                            // 恢复项目状态
                            gridSize = project.gridSize;
                            pixelSize = project.pixelSize;
                            currentColor = project.currentColor;
                            paletteColors = project.paletteColors || [];
                            
                            // 更新UI
                            gridSizeSelect.value = gridSize;
                            pixelSizeSelect.value = pixelSize;
                            colorPicker.value = currentColor;
                            
                            // 恢复画布
                            const img = new Image();
                            img.onload = function() {
                                initCanvas();
                                ctx.drawImage(img, 0, 0);
                                generatePalette();
                            saveState();
                            updateUndoRedoButtons();
                        };
                        img.src = project.canvasData;
                        
                    } catch (error) {
                        alert('加载项目失败: ' + error.message);
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        // 事件监听器
        canvas.addEventListener('mousedown', function(e) {
            if (e.button !== 0) return; // 只响应左键
            isDrawing = true;
            const { x, y } = getGridPosition(e);
            startX = x;
            startY = y;
            
            if (e.ctrlKey || e.metaKey) {
                // 按住Ctrl键(Mac上是Command键)进行填充
                floodFill(x, y, '#ffffff', currentColor);
                saveState();
                isDrawing = false;
                return;
            }
            
            // 如果是渐变模式，初始化随机颜色
            if (isGradientMode && currentTool !== 'eraser') {
                currentColor = getRandomColor();
                colorPicker.value = currentColor;
            }
            
            // 绘制起始点
            if (currentTool === 'pencil' || currentTool === 'eraser') {
                drawPixel(x, y);
            }
        });
        
        canvas.addEventListener('mousemove', function(e) {
            if (!isDrawing) return;
            const { x, y } = getGridPosition(e);
            
            // 临时画布用于预览
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            
            switch(currentTool) {
                case 'pencil':
                    if (isGradientMode) {
                        // 在渐变模式下，每次移动时轻微改变颜色
                        currentColor = getRandomColor(currentColor);
                        colorPicker.value = currentColor;
                    }
                    drawPixel(x, y);
                    break;
                case 'eraser':
                    drawPixel(x, y);
                    break;
                case 'line':
                    drawLine(startX, startY, x, y);
                    break;
                case 'rectangle':
                    if (e.shiftKey) {
                        // 按住Shift键绘制正方形
                        const size = Math.max(Math.abs(x - startX), Math.abs(y - startY));
                        const endX = startX + (x > startX ? size : -size);
                        const endY = startY + (y > startY ? size : -size);
                        drawRectangle(startX, startY, endX, endY, !e.altKey);
                    } else {
                        drawRectangle(startX, startY, x, y, !e.altKey);
                    }
                    break;
                case 'circle':
                    if (e.shiftKey) {
                        // 按住Shift键绘制正圆
                        const radius = Math.max(Math.abs(x - startX), Math.abs(y - startY));
                        const endX = startX + (x > startX ? radius : -radius);
                        const endY = startY + (y > startY ? radius : -radius);
                        drawCircle(startX, startY, endX, endY, !e.altKey);
                    } else {
                        drawCircle(startX, startY, x, y, !e.altKey);
                    }
                    break;
            }
        });
        
        canvas.addEventListener('mouseup', function() {
            if (isDrawing) {
                saveState();
                updateUndoRedoButtons();
            }
            isDrawing = false;
        });
        
        // 工具选择变化
        drawingToolSelect.addEventListener('change', function() {
            currentTool = this.value;
            
            // 更新橡皮擦按钮状态
            const eraserBtn = document.querySelector('option[value="eraser"]');
            if (eraserBtn) {
                if (currentTool === 'eraser') {
                    eraserBtn.classList.add('eraser-active');
                } else {
                    eraserBtn.classList.remove('eraser-active');
                }
            }
        });
        
        canvas.addEventListener('mouseleave', function() {
            isDrawing = false;
        });
        
        gridSizeSelect.addEventListener('change', initCanvas);
        pixelSizeSelect.addEventListener('change', initCanvas);
        colorPicker.addEventListener('input', function() {
            currentColor = this.value;
        });
        
        randomColorBtn.addEventListener('click', function() {
            currentColor = getRandomColor();
            colorPicker.value = currentColor;
        });

        // 渐变模式按钮
        const gradientModeBtn = document.getElementById('gradientMode');
        gradientModeBtn.addEventListener('click', function() {
            isGradientMode = !isGradientMode;
            // 激活时显示蓝色，取消时恢复默认颜色
            if (isGradientMode) {
                this.style.backgroundColor = '#2980b9';
                this.style.transition = 'background-color 0.3s ease';
            } else {
                this.style.backgroundColor = '';
            }
        });
        
        templateSelect.addEventListener('change', function() {
            if (this.value) {
                applyTemplate(this.value);
                this.value = '';
            }
        });
        
        imageUpload.addEventListener('change', function() {
            if (this.files && this.files[0]) {
                importImage(this.files[0]);
                this.value = ''; // 清除选择，以便可以重复选择同一文件
            }
        });
        
        clearCanvasBtn.addEventListener('click', function() {
            drawGrid();
            saveState();
            updateUndoRedoButtons();
        });
        
        exportPNGBtn.addEventListener('click', exportToPNG);
        
        // 项目保存/加载
        const saveProjectBtn = document.getElementById('saveProject');
        const loadProjectBtn = document.getElementById('loadProject');
        
        saveProjectBtn.addEventListener('click', saveProject);
        loadProjectBtn.addEventListener('click', loadProject);


        
        // 撤销/重做按钮
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        
        // 更新按钮状态
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
        }
        
            // 键盘事件监听
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z') {
                        undo();
                        e.preventDefault();
                    } else if (e.key === 'y') {
                        redo();
                        e.preventDefault();
                    }
                }
                
                // 快速切换工具快捷键
                if (e.key === 'e') {
                    // 切换到橡皮擦
                    drawingToolSelect.value = 'eraser';
                    drawingToolSelect.dispatchEvent(new Event('change'));
                } else if (e.key === 'b') {
                    // 切换到铅笔
                    drawingToolSelect.value = 'pencil';
                    drawingToolSelect.dispatchEvent(new Event('change'));
                }
            });

            // 动画管理器
            const animationManager = {
                frames: [],
                isPlaying: false,
                frameRate: 12,
                currentFrameIndex: 0,
                animationInterval: null,
                selectedFrameIndex: -1,
                
                addFrame: function() {
                    const frameData = canvas.toDataURL('image/png');
                    this.frames.push(frameData);
                    this.selectedFrameIndex = this.frames.length - 1;
                    this.updateFramesPreview();
                },
                
                deleteFrame: function(index) {
                    if (index >= 0 && index < this.frames.length) {
                        this.frames.splice(index, 1);
                        if (this.selectedFrameIndex >= this.frames.length) {
                            this.selectedFrameIndex = this.frames.length - 1;
                        }
                        this.updateFramesPreview();
                    }
                },
                
                copyFrame: function(index) {
                    if (index >= 0 && index < this.frames.length) {
                        this.frames.splice(index + 1, 0, this.frames[index]);
                        this.selectedFrameIndex = index + 1;
                        this.updateFramesPreview();
                    }
                },
                
                play: function() {
                    if (this.frames.length === 0) return;
                    
                    this.isPlaying = true;
                    this.currentFrameIndex = 0;
                    this.playNextFrame();
                },
                
                playNextFrame: function() {
                    if (!this.isPlaying) return;
                    
                    const frame = this.frames[this.currentFrameIndex];
                    const img = new Image();
                    img.onload = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0);
                        
                        // 更新当前选中帧索引
                        this.selectedFrameIndex = this.currentFrameIndex;
                        // 更新进度条和帧数显示
                        this.updateProgressBar();
                        
                        this.currentFrameIndex++;
                        if (this.currentFrameIndex >= this.frames.length) {
                            this.currentFrameIndex = 0;
                        }
                        
                        const delay = 1000 / this.frameRate;
                        this.animationInterval = setTimeout(() => this.playNextFrame(), delay);
                    };
                    img.src = frame;
                },
                
                stop: function() {
                    this.isPlaying = false;
                    clearTimeout(this.animationInterval);
                },
                
                updateFramesPreview: function() {
                    const previewContainer = document.getElementById('framesPreview');
                    previewContainer.innerHTML = '';
                    
                    this.frames.forEach((frame, index) => {
                        const framePreview = document.createElement('div');
                        framePreview.className = 'frame-preview';
                        framePreview.innerHTML = `
                            <img src="${frame}" width="50" height="50">
                            <span>${index + 1}</span>
                        `;
                        previewContainer.appendChild(framePreview);
                    });
                },
                
                setFrameRate: function(rate) {
                    this.frameRate = rate;
                    document.getElementById('frameRateValue').textContent = `${rate} FPS`;
                },
                
                updateProgressBar: function() {
                    const progressBar = document.getElementById('frameProgress');
                    const currentFrameEl = document.getElementById('currentFrame');
                    const totalFramesEl = document.getElementById('totalFrames');

                    // 计算总帧数(基于frames数组长度)，确保最小值为1
                    const totalFrames = this.frames.length;
                    const displayFrames = Math.max(1, totalFrames);
                    
                    // 更新显示
                    totalFramesEl.textContent = displayFrames;
                    progressBar.max = displayFrames;
                    
                    // 设置当前帧显示，确保在有效范围内
                    const currentFrame = Math.min(
                        Math.max(1, this.selectedFrameIndex + 1),
                        displayFrames
                    );
                    progressBar.value = currentFrame;
                    currentFrameEl.textContent = currentFrame;
                },
                
                showFrame: function(index) {
                    if (index >= 0 && index < this.frames.length) {
                        const frame = this.frames[index];
                        const img = new Image();
                        img.onload = () => {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(img, 0, 0);
                        };
                        img.src = frame;
                        this.selectedFrameIndex = index;
                        document.getElementById('currentFrame').textContent = index + 1;
                    }
                }
            };
            
            // 进度条事件监听
            const frameProgress = document.getElementById('frameProgress');
            frameProgress.addEventListener('input', function() {
                // 进度条值从1开始，对应帧索引需要减1
                const frameIndex = Math.max(0, parseInt(this.value) - 1);
                animationManager.showFrame(frameIndex);
            });
            
            // 确保进度条范围正确
            frameProgress.min = 1;
        
        // 生成调色板
        function generatePalette() {
            const palette = document.getElementById('colorPalette');
            palette.innerHTML = '';
            
            paletteColors.forEach((color, index) => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'palette-color';
                colorDiv.style.backgroundColor = color;
                colorDiv.title = color;
                colorDiv.style.width = '20px';
                colorDiv.style.height = '20px';
                colorDiv.style.display = 'inline-block';
                colorDiv.style.margin = '2px';
                colorDiv.style.cursor = 'pointer';
                colorDiv.style.border = '1px solid #ddd';
                
                colorDiv.addEventListener('click', function() {
                    currentColor = color;
                    colorPicker.value = color;
                });
                
                // 右键删除颜色
                colorDiv.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    paletteColors.splice(index, 1);
                    localStorage.setItem('paletteColors', JSON.stringify(paletteColors));
                    generatePalette();
                });
                
                palette.appendChild(colorDiv);
            });
        }
        
        // 保存当前颜色到调色板
        document.getElementById('saveColorBtn').addEventListener('click', function() {
            const color = colorPicker.value;
            if (!paletteColors.includes(color)) {
                paletteColors.push(color);
                localStorage.setItem('paletteColors', JSON.stringify(paletteColors));
                generatePalette();
            }
        });
        
        // 动画控制按钮事件监听
        document.getElementById('addFrame').addEventListener('click', function() {
            animationManager.addFrame();
            animationManager.updateProgressBar();
        });

        document.getElementById('deleteFrame').addEventListener('click', function() {
            if (animationManager.selectedFrameIndex >= 0) {
            animationManager.deleteFrame(animationManager.selectedFrameIndex);
            animationManager.updateProgressBar();
            }
        });

        document.getElementById('copyFrame').addEventListener('click', function() {
            if (animationManager.selectedFrameIndex >= 0) {
            animationManager.copyFrame(animationManager.selectedFrameIndex);
            animationManager.updateProgressBar();
            }
        });

        document.getElementById('playAnimation').addEventListener('click', function() {
            if (animationManager.isPlaying) {
                animationManager.stop();
                this.textContent = '播放';
                this.style.backgroundColor = '';
            } else {
                animationManager.play();
                this.textContent = '停止';
                this.style.backgroundColor = '#2ecc71';
            }
        });

        // document.getElementById('stopAnimation').addEventListener('click', function() {
        //     animationManager.stop();
        //     document.getElementById('playAnimation').textContent = '播放';
        //     document.getElementById('playAnimation').style.backgroundColor = '';
        // });

        // 帧预览点击事件
        document.getElementById('framesPreview').addEventListener('click', function(e) {
            const frameElement = e.target.closest('.frame-preview');
            if (frameElement) {
                const index = Array.from(this.children).indexOf(frameElement);
                if (index >= 0) {
                    animationManager.selectedFrameIndex = index;
                    // 高亮选中的帧
                    this.querySelectorAll('.frame-preview').forEach((el, i) => {
                        el.style.borderColor = i === index ? '#ff9933' : '#5a3921';
                    });
                    
                    // 加载选中帧到画布
                    const frame = animationManager.frames[index];
                    const img = new Image();
                    img.onload = function() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0);
                        // 更新进度条和帧数显示
                        animationManager.updateProgressBar();
                    };
                    img.src = frame;
                }
            }
        });

        document.getElementById('frameRate').addEventListener('input', function() {
            const frameRate = parseInt(this.value);
            animationManager.setFrameRate(frameRate);
        });

        // 初始化
        initCanvas();
        generatePalette();
        updateUndoRedoButtons();
        saveState(); // 保存初始状态
        animationManager.updateProgressBar(); // 初始化进度条状态
        
        // 添加画布缩放功能
        let scaleFactor = 1.0; // 初始缩放比例
        const SCALE_STEP = 0.1; // 每次缩放增量
        const MIN_SCALE = 0.5;
        const MAX_SCALE = 4;

        canvas.addEventListener('wheel', function(e) {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault(); // 防止页面缩放
                if (e.deltaY < 0) {
                    // 放大
                    scaleFactor = Math.min(MAX_SCALE, scaleFactor + SCALE_STEP);
                } else {
                    // 缩小
                    scaleFactor = Math.max(MIN_SCALE, scaleFactor - SCALE_STEP);
                }
                canvas.style.transform = `scale(${scaleFactor})`;
                canvas.style.transformOrigin = '0 0'; // 从左上角缩放
            }
        }, { passive: false }); // 必须设置为 false 才能调用 preventDefault
    });
</script>